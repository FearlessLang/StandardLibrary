package base;

DataType[T]: ToStr, ToInfo, WidenTo[T], ToImm[T], OrderHash[T], _AssertEq[T]{
  .close(x:T):DataType[T];
  .close:T;
}
GenDataType[T,E]: ToStr[E], ToInfo[E], WidenTo[T], ToImm[T,E], OrderHash[T,E], _AssertEqGen[T,E]{
  .close(x:T):GenDataType[T,E];
  .close:T;
  .dataType(by: DataTypeBy[E]): DataType[T] -> {'self
    .close(x:T): DataType[T] -> this.close(x).dataType(by);
    .close: T -> this.close;
    .str: Str -> this.str(by);
    .info: Info -> this.info(by);
    .imm: T -> this.imm(by);
    .cmp(a:Order[T],b:Order[T]): Ordering -> this.orderH(by).cmp(a,b);
    .hash(h: mut Hasher): Nat -> this.orderH(by).hash(h);
  };
}
DataTypeBy[E]:ToStrVia[E],ToInfoVia[E],ToImmVia[E],OrderHashBy[E]{
  #(e:E): DataType[E];
}
ToImm[R]:{ read .imm: R }
ToImmVia[A]:{#(A):ToImm[A]}
ToImm[T,E]:{ read .imm(ToImmVia[E]): T }

ToStr:{ read .str: Str }
ToStrVia[A:**]:{#(A):ToStr}
ToStr[A:**]:{ read .str(ToStrVia[A]): Str }
ToInfo:{ read .info: Info }
FromInfo[T]:{ .fromInfo(i: Info): T }
ToInfoVia[A:**]:{#(A):ToInfo}
ToInfo[A:**]:{ read .info(via: ToInfoVia[A]): Info }

Ordering:Sealed, WidenTo[Ordering]{
  .match[R:**](m: OrderingMatch[R]): R;
  &&(o: mut MF[Ordering]): Ordering -> this;
  .and(o: Ordering): Ordering -> this;
  }
OrderingMatch[R:**]: { .lt: R; .eq: R; .gt: R }
OrderingLt: Ordering{::.lt }
OrderingEq: Ordering{::.eq; &&(o)-> o#; .and(o)->o }
OrderingGt: Ordering{::.gt }
Orderings:{/*..consistend with other enums contains list of elements etc..*/}

.cmp(a,b,lt,eq,gt)->
  o1.cmp(a,b,{lt},{o2.cmp(a,b,lt,eq,gt)},{gt})#;
Order[T]: {
  .cmp(a:Order[T], b:Order[T]): Ordering; //only abstract method used to implement all the others
  <=> (other: Order[T]): Ordering -> this.cmp(this, other);
  ==  (other: Order[T]): Bool -> this <=> other .match{ .lt->False; .eq->True; .gt->False};
  <=  (other: Order[T]): Bool -> this <=> other .match{ .lt->True;  .eq->True; .gt->False};
  >=  (other: Order[T]): Bool -> this <=> other .match{ .lt->False; .eq->True; .gt->True };
  <   (other: Order[T]): Bool -> this <=> other .match{ .lt->True;  .eq->False;.gt->False};
  >   (other: Order[T]): Bool -> this <=> other .match{ .lt->False; .eq->False;.gt->True };
  !=  (other: Order[T]): Bool -> this <=> other .match{ .lt->True;  .eq->False;.gt->True };
  .inRange(lo:Order[T], hi:Order[T]):Bool-> Block#(Assert!(_LE#(this,lo,hi)), this >= lo  &&{ this <= hi });        /// true iff this in [lo,hi]; throws if lo>hi or lo/hi are NaN
  .inRangeOpen(lo:Order[T], hi:Order[T]):Bool-> Block#(Assert!(_LE#(this,lo,hi)), this > lo  &&{ this < hi });      /// true iff this in (lo,hi); throws if lo>hi or lo/hi are NaN
  .inRangeLoOpen(lo:Order[T], hi:Order[T]):Bool-> Block#(Assert!(_LE#(this,lo,hi)), this > lo  &&{ this <= hi });   /// true iff this in (lo,hi]; throws if lo>hi or lo/hi are NaN
  .inRangeHiOpen(lo:Order[T], hi:Order[T]):Bool-> Block#(Assert!(_LE#(this,lo,hi)), this >= lo  &&{ this < hi });   /// true iff this in [lo,hi); throws if lo>hi or lo/hi are NaN
  }
_LE:{ #[T](o:Order[T],a:Order[T], b:Order[T]): Bool ->
  o.cmp(a,b).match{ .lt->True; .eq->True; .gt->False }; }
OrderBy[T]:{
  #(Order[T]):Order[T];
  .cmp(a:Order[T],b:Order[T]):Ordering -> this#a <=> b;
  &&(other:OrderBy[T]):OrderByCmp[T] -> { a,b-> this.cmp(a,b) && { other.cmp(a,b) }};
  .and(other:OrderBy[T]):OrderByCmp[T] -> {a,b-> this.cmp(a,b).and(other.cmp(a,b))};
  .view[A](f:F[Order[A],Order[T]]):OrderByCmp[A] -> {a,b-> this.cmp(f#a,f#b)};
}
OrderByCmp[T]:OrderBy[T]{
  .cmp(a:Order[T],b:Order[T]):Ordering;//sets this as abstract
  # a0 -> {
     <=> b   -> this.cmp(a0,b);
    .cmp a,b -> this.cmp(a,b);
    };
  }
Order[T,E]:{ .order(by: OrderBy[E]): Order[T] }//for ordering lists

Hasher: {
  mut #[A,B](a: OrderHash[A], b: OrderHash[B]): Nat -> a.hash(this) * 31 + (b.hash(this));
  //#[A,B,C](a: OrderHash[A], b: OrderHash[B], c: OrderHash[C]): Nat -> ...;
  //...//more overloads to compose more values
  mut .nat(v: Nat): Nat->v;
  mut .int(v: Int): Nat->Todo!;
  mut .num(v: Num): Nat->Todo!;
  mut .float(v: Float): Nat->Todo!;
  mut .byte(v: Byte): Nat->Todo!;
  mut .bool(v: Bool): Nat->v?{.then->0; .else->1};
  mut .info(i: Info): Nat->this.str(i.str); 
  mut .str(v: Str): Nat->Todo!;  
  mut .list[E](f: OrderHashBy[E],l: List[E]):Nat->Todo!;
  mut .opt[E](f: OrderHashBy[E], o: Opt[E]):Nat->Todo!;
  mut .map[K,E](f: OrderHashBy[E], m: Map[K,E]):Nat->Todo!;
  }
OrderHash[T]:Order[T]{ .hash(h: mut Hasher): Nat }
OrderHash[T,E]:{ .orderH(by: OrderHashBy[E]): OrderHash[T] }
OrderHashBy[T]:{
  #(x:T):OrderHash[T];
  .cmp(a:OrderHash[T],b:OrderHash[T]):Ordering -> a <=> b;
  .hash(a:OrderHash[T],h: mut Hasher):Nat -> a.hash(h);
  &&(other:OrderHashBy[T]):OrderHashByCmp[T] -> {
    .cmp(a,b)-> this.cmp(a,b) && { other.cmp(a,b) };
    .hash(a,h)-> h#(this#a, other#a);
  };
  .and(other:OrderHashBy[T]):OrderHashByCmp[T] -> {
    .cmp(a,b)-> this.cmp(a,b).and(other.cmp(a,b));
    .hash(a,h)-> h#(this#a, other#a);
  };
  .view[A](f:F[OrderHash[A],OrderHash[T]]):OrderHashByCmp[A] -> {
    .cmp(a,b)-> this.cmp(f#a,f#b);
    .hash(a,h)-> this.hash(f#a,h);
  };
}
OrderHashByCmp[T]:OrderHashBy[T]{
  .cmp(a:OrderHash[T],b:OrderHash[T]):Ordering;      
  .hash(a:OrderHash[T],h: mut Hasher):Nat;
  #(x:T):OrderHash[T] -> {
    <=> (other:OrderHash[T]):Ordering -> this.cmp(x,other);
    .cmp(a,b):Ordering -> this.cmp(a,b);
    .hash(h):Nat -> this.hash(x,h);
  };
}

/*Comparators is now dead!
We can now do
Ints.orderBy.view{::.age} && (Strs.orderBy.view{::.name})
and get an OrderBy[Person]
We can avoid view and overload orderBy:
Ints.orderBy{::.age} && (Strs.orderBy{::.name})
This is still sad, since we need Ints,Strs; we can not expect
user defined types to follow the pattern.
Instead the below should work (basically what Java does)
.max(Orders#{::.age} && { ::.name})
.max(Older && { ::.name})//works too
.max(Older && Taller)//works too
OlderAndTaller:OrderBy[Person]{a->{b->{Older && Taller #(a,b)}}
Orders:{#[T](t:OrderBy[T]):OrderBy[T]->t}
We can, for simplicity, also have
Orders:{
  #[T](t:OrderBy[T]):OrderBy[T]->t
  #[T](t1:OrderBy[T],t2:OrderBy[T]):OrderBy[T]->t1 && t2... but why?
  }
Or, we improve inference with guessing:
if e.m({..}.foo) and {..} does not declare a .foo method with type,
currently this is going to fail.
We can instead guess that {..} has the type needed by .m arg 1.
With this guessing, all the .andThen patterns would work
e.max({::.name} && {::.age})
No need of `Orders#` with this inference.
*/

//---tests
/*Persons:{#(name:Str, age:Nat):Person -> Person:{.name: Str -> name,  .age: Nat -> age }}
Older:OrderBy[Person]{ p1->{p2 -> p1.age <=> (p2.age) } }
//Yes inferred Older:OrderBy[Person]{ p1-> Order[Person]{p2 -> p1.age <=> (p2.age) } }

Persons:{#(name:Str, age:Num):Person -> Person:Order[Person]{
  .name: Str -> name,
  .age: Nat -> age,
  <=>(other)->this.age <=> (other.age) && {this.name <=> (other.name)},
  }}
*/