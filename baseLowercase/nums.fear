// Num: unlimited-precision rational (exact arithmetic).
Num:Sealed,DataType[Num,Num],_AssertApprox[Num]{
  +(x:Num):Num;                     /// exact add
  -(x:Num):Num;                     /// exact sub
  *(x:Num):Num;                     /// exact mul
  /(x:Num):Num;                     /// exact div; throws iff x==0
  .abs:Num;                         /// exact abs
  .sqrt:Float;                      /// approximate sqrt;s NaN iff this is negative
  .floor:Num;                       /// floor(this);
  .ceil:Num;                        /// ceil(this);
  .trunc0:Num;                      /// trunc toward 0;
  .round:Num;                       /// round-to-nearest integer, ties-to-even (exact on rationals); result is an integer (denominator == 1)
  .isInteger:Bool;                  /// true iff denominator == 1

  .int:Int;                         /// clamp to [minInt,maxInt] after trunc0 (never throws)
  .nat:Nat;                         /// clamp to [0,maxNat] after trunc0 (never throws)
  .byte:Byte;                       /// clamp to [0,maxByte] after trunc0 (never throws)
  .float:Float;                     /// approximate; (never throws)

  .intExact:Opt[Int];               /// .some if integer and in [minInt,maxInt]; .empty otherwise
  .natExact:Opt[Nat];               /// .some if integer and in [0,maxNat]; .empty otherwise
  .byteExact:Opt[Byte];             /// .some if integer and in [0,maxByte]; .empty otherwise
  .clamp(lo:Num, hi:Num):Num;       /// clamp into [lo,hi]; throws if lo>hi
  .hash(h) -> h.num(this.imm);      /// hash via hasher
  .close->::; .close->this;         /// fixpoint type closed
}

/// Float: 64 bits IEEE values. Note: ==/order instead follow the usual rules:
/// - NaN == NaN (all different NaNs equal); NaN is greater than everything else including +Inf
/// - -0.0 == +0.0
/// Method Hasher.float(Float) must respect this ordering
Float:Sealed,DataType[Float,Float],_AssertApprox[Float]{
  +(x:Float):Float;                 /// IEEE add
  -(x:Float):Float;                 /// IEEE sub
  *(x:Float):Float;                 /// IEEE mul
  /(x:Float):Float;                 /// IEEE div: 0 yields +/-Inf or NaN (never throws)
  .abs:Float;                       /// IEEE abs
  .sqrt:Float;                      /// IEEE sqrt; returns NaN iff this is negative (excluding -0)
  .floor:Int;                       /// floor(this) after handling NaN/Inf (policy: clamp+trunc0 into Int)
  .ceil:Int;                        /// ceil(this)  (policy: clamp+trunc0 into Int)
  .trunc0:Int;                      /// trunc toward 0 (policy: clamp+trunc0 into Int)
  .round:Int;                       /// clamp into Int range, round-to-nearest integer, ties-to-even; NaN->0; +Inf->maxInt; -Inf->minInt (never throws)
  **(x:Float):Float;                /// IEEE pow
  .isNaN:Bool;                      /// true iff NaN (any payload)
  .isInfinite:Bool;                 /// true iff +/-Inf
  .isPosInfinity:Bool;              /// true iff +Inf
  .isNegInfinity:Bool;              /// true iff -Inf
  .isNegZero:Bool;                  /// true iff raw bits are -0.0
  .isPosZero:Bool;                  /// true iff raw bits are +0.0

  .ieeeEq(x:Float):Bool;            /// IEEE == (NaN != NaN), but still +0.0 == -0.0
  .ieeeSameBits(x:Float):Bool;      /// raw bits compare: it distinguishes NaN payloads and signed zero
  .ieeeStr:Str;                     /// IEEE 754 round-trip decimal string for this Float (includes NaN/Inf)
  .ieeeRemainder(d:Float):Float;    /// IEEE remainder r = x - n*d with n nearest integer to x/d (ties-to-even)

  .int:Int;                         /// clamp+trunc0; NaN->0; +Inf->maxInt; -Inf->minInt (never throws)
  .nat:Nat;                         /// clamp+trunc0; NaN->0; +Inf->maxNat; -Inf->0 (never throws)
  .byte:Byte;                       /// clamp+trunc0; NaN->0; +Inf->maxByte; -Inf->0 (never throws)
  .numExact:Opt[Num];               /// .some if finite (and convertible under chosen policy); .empty on NaN/Inf

  .intExact:Opt[Int];               /// .some if finite, integral, in [minInt,maxInt]; .empty otherwise
  .natExact:Opt[Nat];               /// .some if finite, integral, in [0,maxNat]; .empty otherwise
  .byteExact:Opt[Byte];             /// .some if finite, integral, in [0,maxByte]; .empty otherwise
  .clamp(lo:Float, hi:Float):Float; /// clamp into [lo,hi]; throws if lo>hi 
  .hash(h) -> h.float(this.imm);    /// hash via hasher
  .close->::; .close->this;         /// fixpoint type closed
}

// Int: signed 32-bit.
// Note: / is not provided; use div/rem (divisor is Nat).
Int:Sealed,DataType[Int,Int]{
  +(x:Int):Int;                     /// checked add; throws on overflow/underflow
  -(x:Int):Int;                     /// checked sub; throws on overflow/underflow
  *(x:Int):Int;                     /// checked mul; throws on overflow/underflow

  .div(d:Nat):Int;                  /// trunc toward 0; throws iff d==0
  .rem(d:Nat):Int;                  /// r = this - (this.div(d))*d; throws iff d==0;
  .divExact(d:Nat):Opt[Int];        /// .some if d!=0 and this.rem(d)==0; .empty otherwise

  .abs:Int;                         /// abs; throws on overflow for minInt
  .sqrt:Float;                      /// approximate sqrt; returns NaN iff this is negative
  .wrapIndex(len:Nat):Nat;          /// normalize into [0,len-1]; throws iff len==0; example: -1.wrapIndex(7) == 6
  .nat:Nat;                         /// clamp to [0,maxNat] (that is, just clamp negatives to 0)
  .byte:Byte;                       /// clamp to [0,maxByte]
  .float:Float;                     /// converts to Float (note: Float can represent exactly all Int values)
  .num:Num;                         /// converts to Num (note: Num can represent exactly all Int values)
  .natExact:Opt[Nat];               /// .some if this >= 0; .empty otherwise
  .byteExact:Opt[Byte];             /// .some if this in [0,maxByte]; .empty otherwise
  .aluAddWrap(x:Int):Int;           /// i32 wraparound add (mod 2^32)
  .aluSubWrap(x:Int):Int;           /// i32 wraparound sub (mod 2^32)
  .aluMulWrap(x:Int):Int;           /// i32 wraparound mul (mod 2^32)
  .aluDiv(x:Int):Int;               /// i32 trunc division; throws iff x == 0; Note: negative divisor allowed here
  .aluRem(x:Int):Int;               /// paired with aluDiv; sign follows dividend; throws iff x == 0
  .aluShiftLeft(bits:Nat):Int;      /// i32 shift-left; effective shift = bits & 31.
  .aluShiftRight(bits:Nat):Int;     /// i32 arithmetic shift-right (sign-ext); effective shift = bits & 31.  
  .aluXor(x:Int):Int;               /// i32 xor
  .aluAnd(x:Int):Int;               /// i32 and
  .aluOr(x:Int):Int;                /// i32 or
  .aluNat:Nat;                      /// reinterpret i32 bits as u32 Nat (bit-cast)
  .aluByte:Byte;                    /// low 8 bits (wrap), not clamp
  .clamp(lo:Int, hi:Int):Int;       /// clamp into [lo,hi]; throws if lo>hi
  .hash(h) -> h.int(this.imm);      /// hash via hasher
  .close->::; .close->this;         /// fixpoint type closed
}
// Nat: 32-bit unsigned (bitty, index-flavored). Ordering is UNSIGNED.
// Note: / is not provided; use div/rem (divisor is Nat).
Nat:Sealed,DataType[Nat,Nat]{
  +(x:Nat):Nat;                     /// checked add; throws on overflow (past maxNat)
  -(x:Nat):Nat;                     /// checked sub; throws on underflow (below 0)
  *(x:Nat):Nat;                     /// checked mul; throws on overflow
  .div(d:Nat):Nat;                  /// trunc toward 0; throws iff d == 0 (Note: Nat trunc and Nat floor are the same concept)
  .rem(d:Nat):Nat;                  /// r = this - (this.div(d))*d;  r in 0..d-1; throws iff d == 0;
  .divExact(d:Nat):Opt[Nat];        /// .some if d != 0 and this.rem(d) == 0; .empty otherwise
  .sqrt:Float;                      /// approximate sqrt
  .indexOffset(delta:Int):Nat;      /// index helper: this + delta; throws on under/overflow
  .int:Int;                         /// clamp to [0,maxInt]
  .byte:Byte;                       /// clamp to [0,maxByte]
  .float:Float;                     /// converts to Float (note: Float can represent exactly all Nat values)
  .num:Num;                         /// converts to Float (note: Num can represent exactly all Nat values)
  .intExact:Opt[Int];               /// .some if this <= maxInt; .empty otherwise
  .byteExact:Opt[Byte];             /// .some if this <= maxByte; .empty otherwise
  .aluAddWrap(x:Nat):Nat;           /// u32 wraparound add (mod 2^32)
  .aluSubWrap(x:Nat):Nat;           /// u32 wraparound sub (mod 2^32)
  .aluMulWrap(x:Nat):Nat;           /// u32 wraparound mul (mod 2^32)
  .aluDiv(x:Nat):Nat;               /// u32 trunc division; throws iff x == 0
  .aluRem(x:Nat):Nat;               /// paired with aluDiv; throws iff x == 0
  .aluShiftLeft(bits:Nat):Nat;      /// u32 shift-left; effective shift = bits & 31 (i.e., modulo 32).
  .aluShiftRight(bits:Nat):Nat;     /// u32 logical shift-right; effective shift = bits & 31.  
  .aluXor(x:Nat):Nat;               /// u32 xor
  .aluAnd(x:Nat):Nat;               /// u32 and
  .aluOr(x:Nat):Nat;                /// u32 or
  .aluInt:Int;                      /// reinterpret u32 bits as i32 Int (bit-cast)
  .aluByte:Byte;                    /// low 8 bits (wrap), not clamp
  .clamp(lo:Nat, hi:Nat):Nat;       /// clamp into [lo,hi]; throws if lo>hi
  .hash(h) -> h.nat(this.imm);      /// hash via hasher
  .close->::; .close->this;         /// fixpoint type closed
}

// Byte: 8-bit unsigned [0,255]. Ordering is UNSIGNED.
// Note: / is not provided; use div/rem (divisor is Nat).
Byte:Sealed,DataType[Byte,Byte]{
  +(x:Byte):Byte;                   /// checked add; throws on overflow (past 255)
  -(x:Byte):Byte;                   /// checked sub; throws on underflow (below 0)
  *(x:Byte):Byte;                   /// checked mul; throws on overflow
  .div(d:Nat):Byte;                 /// trunc toward 0; throws iff d == 0
  .rem(d:Nat):Byte;                 /// r = this - (this.div(d))*d; throws iff d == 0
  .divExact(d:Nat):Opt[Byte];       /// .some if d != 0 and this.rem(d) == 0; .empty otherwise
  .sqrt:Float;                      /// approximate sqrt
  .nat:Nat;                         /// exact widen
  .int:Int;                         /// exact widen
  .float:Float;                     /// exact widen
  .num:Num;                         /// exact widen to rational
  .aluAddWrap(x:Byte):Byte;         /// u8 wraparound add (mod 256)
  .aluSubWrap(x:Byte):Byte;         /// u8 wraparound sub (mod 256)
  .aluMulWrap(x:Byte):Byte;         /// u8 wraparound mul (mod 256)
  .aluDiv(x:Byte):Byte;             /// u8 trunc division; throws iff x == 0
  .aluRem(x:Byte):Byte;             /// paired with aluDiv; throws iff x == 0
  .aluShiftLeft(bits:Nat):Byte;     /// u8 shift-left; effective shift = bits & 7 (i.e., modulo 8).
  .aluShiftRight(bits:Nat):Byte;    /// u8 logical shift-right; effective shift = bits & 7.
  .aluXor(x:Byte):Byte;             /// u8 xor
  .aluAnd(x:Byte):Byte;             /// u8 and
  .aluOr(x:Byte):Byte;              /// u8 or
  .clamp(lo:Byte, hi:Byte):Byte;    /// clamp into [lo,hi]; throws if lo>hi
  .hash(h) -> h.byte(this.imm);     /// hash via hasher
  .close->::; .close->this;         /// fixpoint type closed
}