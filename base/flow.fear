Flows:{
  #[R:*]:mut Flow[R]->Magic!;
  #[R:*](r1:R):mut Flow[R]->Magic!;
  #[R:*](r1:R,r2:R):mut Flow[R]->Magic!;
  #[R:*](r1:R,r2:R,r3:R):mut Flow[R]->Magic!;
  #[R:*](r1:R,r2:R,r3:R,r4:R):mut Flow[R]->Magic!;
  .fromMutList[R:*](xs: mut List[R]): mut Flow[R]->Magic!;
  .fromReadList[R:*](xs: read List[R]): mut Flow[read/imm R]->Magic!;
  .fromImmList[R:*](xs: List[R]): mut Flow[imm R]->Magic!;
  }
Flow[E:*]:{
  mut .forEach[R:*](f: mut MF[E,Void]): Void;
  mut .map[R:*](f: read F[E, R]): mut Flow[R];
  mut .filter(f: read F[E, Bool]): mut Flow[E];
  mut .size: Nat;
  mut .isEmpty: Bool -> this.size == 0;
  mut ++ (mut Flow[E]): mut Flow[E];
  mut .list: mut List[E];
  mut .fold[R:*](acc: iso MF[R], f: read F[R,E,R]): R;
  mut .mapping[K,E0:*](OrderHashBy[K,K],read KeyElemMapper[E,K,E0]):mut Map[K,E0];
  mut .join(js: JoinStr[E]): E -> js.joinStr this;
  }
JoinStr[E:*]:Sealed{ .joinStr(mut Flow[E]): E }