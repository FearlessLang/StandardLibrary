package base;

Main: { .main(s: mut System): Void }
Sealed: {}
Void: Sealed{}
WidenTo[T]:{}
InferUnknown:Sealed{}
InferErr[A,B]:Sealed{}
InferErr[A,B,C]:Sealed{}
InferErr[A,B,C,D]:Sealed{}

ToIso[R]: {mut .iso: iso ToIso[R]; mut .self: mut R;}

Abort: Sealed{![R:**]: R -> _Throw.nonDeterministic(Infos.msg `Abort reached`);}
Magic: Sealed{
  ![R:**]: R -> this!; // magic'd out to tell us what we forgot to implement
  //![R:**](_: mut _System): R -> _Throw.nonDeterministic(Infos.msg `Abort reached`);
  }
Debug: Sealed{
  #[T:*](x: T, f:F[T,Str]): T -> Block#(this#(f#x),x);
  #(x: read ToStr): Void -> Magic!;
  //.identify[T](x: read T): Str -> Magic!;//TODO: can this break observability?
  }
As[X:**]: Sealed{ #(x: X): X -> x }

Let: { #[A:*,R:**](l: mut Let[A, R]): R -> l.in(l.let); }
Let[A:*,R:**]: { mut .let: A; mut .in(a: A): R }

F[R:**]: { read #: R; }
F[A:**,R:**]: { read #(a: A): R }
F[A:**, B:**, R:**]: { read #(a: A, b: B): R }
F[A:**, B:**, C:**, R:**]: { read #(a: A, b: B, c: C): R }
F[A:**, B:**, C:**, D:**, R:**]: { read #(a: A, b: B, c: C, d: D): R }

MF[R:**]: { mut #: R }
MF[A:**,R:**]: { mut #(a: A): R }
MF[A:**, B:**, R:**]: { mut #(a: A, b: B): R }
MF[A:**, B:**, C:**, R:**]: { mut #(a: A, b: B, c: C): R }
MF[A:**, B:**, C:**, D:**, R:**]: { mut #(a: A, b: B, c: C, d: D): R }
  
//To slowly move to other files

UStr:Sealed,WidenTo[UStr]{}
ToUStr:{ read .uStr: UStr }

StrProcs:{
  imm .add(a:Str,b:ToStr): mut StrProc -> this.add(a,b);
  }
StrProc:{
  mut .add(a:Str,b:ToStr): mut StrProc -> this.add(a,b);
  mut .build(a:Str): Str-> a;
  }
UStrProcs:{
  imm .add(a:UStr,b:ToUStr): mut UStrProc -> this.add(a,b);
  }
UStrProc:{
  mut .add(a:UStr,b:ToUStr): mut UStrProc -> this.add(a,b);
  mut .build(a:UStr): UStr-> a;
  }