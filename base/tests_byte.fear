ByteArith:F[Tests,Tests]{::
  .test(+1.byte + (+2.byte) .assertEq (+3.byte))
  .test(+5.byte - (+2.byte) .assertEq (+3.byte))
  .test(+3.byte * (+4.byte) .assertEq (+12.byte))
  .test(+9.byte.sqrt .assertEq +3.0)

  // Unsigned ordering
  .test(+255.byte .assertGt (+0.byte))
  .test(+0.byte .assertLt (+255.byte))
}

ByteDivRem:F[Tests,Tests]{::
  .test(+7.byte.div 3 .assertEq (+2.byte))
  .test(+7.byte.rem 3 .assertEq (+1.byte))

  .test(+6.byte.divExact 3 .assertEq ({::},Opts#(+2.byte)))
  .test(+7.byte.divExact 3 .assertEq ({::},Opt[Byte]))
  .test(+7.byte.divExact 0 .assertEq ({::},Opt[Byte]))
}

ByteConv:F[Tests,Tests]{::
  .test(+0.byte.nat .assertEq 0)
  .test(+0.byte.int .assertEq +0)

  .test(+255.byte.nat .assertEq 255)
  .test(+255.byte.int .assertEq +255)
  .test(+5.byte.float .assertEq +5.0)
  .test(+255.byte.float .assertEq +255.0)

  .test(+5.byte.num .assertEq (+5.num))
}

ByteAlu:F[Tests,Tests]{::
  .test(+250.byte.aluAddWrap(+10.byte) .assertEq (+4.byte))
  .test(+0.byte.aluSubWrap(+1.byte) .assertEq (+255.byte))
  .test(+16.byte.aluMulWrap(+16.byte) .assertEq (+0.byte))

  // effective shift = bits & 7
  .test(+1.byte.aluShiftLeft 8 .assertEq (+1.byte))
  .test(+1.byte.aluShiftLeft 9 .assertEq (+2.byte))
  .test(+128.byte.aluShiftRight 1 .assertEq (+64.byte))
  .test(+2.byte.aluShiftRight 9 .assertEq (+1.byte))

  .test(+5.byte.aluXor(+3.byte) .assertEq (+6.byte))
  .test(+5.byte.aluAnd(+3.byte) .assertEq (+1.byte))
  .test(+5.byte.aluOr(+2.byte) .assertEq (+7.byte))

  // aluDiv / aluRem (unsigned)
  .test(+250.byte.aluDiv(+10.byte) .assertEq (+25.byte))
  .test(+250.byte.aluRem(+10.byte) .assertEq (+0.byte))
  .test(+255.byte.aluDiv(+2.byte) .assertEq (+127.byte))
  .test(+255.byte.aluRem(+2.byte) .assertEq (+1.byte))
}

ByteRange:F[Tests,Tests]{::
  .test(+3.byte.assertInRange(+1.byte,+5.byte))
  .test(+3.byte.assertInRangeOpen(+1.byte,+5.byte))
  .test(+3.byte.assertInRangeLoOpen(+1.byte,+3.byte))
  .test(+3.byte.assertInRangeHiOpen(+3.byte,+5.byte))

  .test(+0.byte.clamp(+1.byte,+5.byte) .assertEq (+1.byte))
  .test(+6.byte.clamp(+1.byte,+5.byte) .assertEq (+5.byte))
  .test(+3.byte.clamp(+1.byte,+5.byte) .assertEq (+3.byte))
  .test(+3.byte.clamp(+3.byte,+3.byte) .assertEq (+3.byte))
}
ByteBoundaryAndBoundedVsAlu:F[Tests,Tests]{::
  //.test(+250.byte + (+10.byte) .assertEq (+255.byte))// correctly throws instead
  .test(+250.byte.aluAddWrap(+10.byte) .assertEq (+4.byte))

  //.test(+0.byte - (+1.byte) .assertEq (+0.byte))// correctly throws instead
  .test(+0.byte.aluSubWrap(+1.byte) .assertEq (+255.byte))

  // 16*16 = 256, bounded should differ from wrap
  //.test(+16.byte * (+16.byte) .assertEq (+255.byte))// correctly throws instead
  .test(+16.byte.aluMulWrap(+16.byte) .assertEq (+0.byte))

  //.test(+255.byte + (+1.byte) .assertEq (+255.byte))// correctly throws instead
  .test(+255.byte.aluAddWrap(+1.byte) .assertEq (+0.byte))
}
