package base;

Infos:Sealed {
  .msg(str: Str): Info -> str.isEmpty?{
    .then->{};
    .else->{'i
      .match->::.msg str;
      .msg -> str;
      .imm->i;
      }};
  .list(i1: read ToInfo): Info -> Lists#(i1.info).info{::};
  .list(i1: read ToInfo, i2: read ToInfo): Info -> Lists#(i1.info,i2.info).info{::};
  .map(k1: Str, e1: read ToInfo): Info-> Maps#({::},k1,e1.info).info{::};
  .map(k1: Str, e1: read ToInfo,k2: Str, e2: read ToInfo): Info-> Maps#({::},k1,e1.info,k2,e2.info).info{::};
  }
//To make an info from arbitrary map/list, just do myList.info{::} or myMap.info{::}
//how to turn keys into string is part of the key datatype of map
//will have to synthetize fresh key suffix if the str is already in there.

Info:Sealed,DataType[Info,Info],_AssertImmEmpty{
  .close->::; .close->this;
  .info->this.imm;
  .imm->{};
  .hash->::.info (this.imm);
  .cmp a,b,m -> a.str <=> (b.str, m);
  .msg:Str->``;
  .list:List[Info]->{};
  .map:Map[Str,Info]->Maps#[Str,Str,Info]{::};
  .isEmpty:Bool ->this.msg.isEmpty .and (this.list.isEmpty) .and (this.map.isEmpty);
  .match[R](m: InfoMatch[R]): R->m.empty;
  .str -> this.imm.match(_InfoToStr);
  +(other:Info) : Info -> this.match{
    .empty -> other;
    .msg(s1) -> other.match{
      .empty   -> this;
      .msg(s2) -> Infos.msg(s1|s2);
      .list(l2)-> Infos.map(`msg`,s1,`list`,l2.info{::});
      .map(_)  -> Infos.map(`msg`,s1)+other
      };
    .list(l1) -> other.match{
      .empty   -> this;
      .msg(s2) -> Infos.map(`msg`,s2,`list`,l1.info{::});
      .list(l2)-> l1 ++ l2 .info{::};
      .map(_)  -> Infos.map(`list`,l1.info{::}) + other;
      };
    .map(m1) -> other.match{
      .empty   -> this;
      .msg  s2 -> _InfoMapPlus#(m1, Infos.map(`msg`,s2).map) .info{::};
      .list l2 -> _InfoMapPlus#(m1, Infos.map(`list`,l2.info{::}).map) .info{::};
      .map  m2 -> _InfoMapPlus#(m1, m2) .info{::};
      };
    };
  }
_InfoMapPlus:{ #[K](m1: Map[K,Info], m2: Map[K,Info]): Map[K,Info] ->
  m2.flow.fold({m1}, {acc,ke->
    acc.opt(ke.key).match{
      .empty -> acc.with(ke.key, ke.elem);
      .some v -> acc.with(ke.key, v+(ke.elem));
    };
  });}
_InfoFreshKey:{
  #(m: Map[Str,Info], base: Str, i: Nat): Str -> Block#
    .let k= {i == 0 ? {.then->base; .else->base + `#` + i.str; }}
    .return{ m.containsKey(k)?{
      .then -> this#(m, base, i + 1);
      .else -> k;
  }};}

InfoMatch[R]:{
  .empty:R;
  .msg(Str): R;
  .list(List[Info]): R;
  .map(Map[Str,Info]): R;
  }
_InfoToStr: InfoMatch[Str]{
  .empty ->`EmptyInfo`;
  .msg(msg) -> msg.escape;
  .list(list) -> list.str{::};
  .map(map) -> map.str{::};
  }