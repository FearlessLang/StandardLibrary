package base;

/// DataType sits on top of OrderHash:
///   Order > OrderHash > DataType
/// It adds:
/// - Info (for easy serialization/deserialization/exceptions)
/// - deep imm conversion
/// - widen/equality helpers (defined elsewhere)
///
/// Fixpoint story:
/// - OrderHash[T] already provides the closed value .close:T allowing to this this as a T
/// - DataType adds the opposide direction .close(t:T):DataType[...] allowing to this T as DataType[T]

ToImm[T0]:{ read .imm: T0 }                     /// deep immutable representation (may change type)
ToImmBy[T,T0]:{#(t: read T):read ToImm[T0]}       /// per-value ToImm dictionary
ToImm[T,E:*,T0]:{ read .imm(by: ToImmBy[imm E,T0]): T0 }  /// env-dependent deep imm

ToInfo:{ read .info: Info }                     /// structured diagnostics info
ToInfoBy[T]:{#(t: read T):read ToInfo}            /// per-value Info dictionary
ToInfo[E:*]:{ read .info(by: ToInfoBy[imm E]): Info }     /// env-dependent Info

FromInfo[T]:{ .fromInfo(i: Info): T }            /// parse/decode from Info

DataType[T,T0]:ToInfo,ToImm[T0],WidenTo[T],OrderHash[T]{
  read .close(t: read T): read DataType[T,T0];                    /// close on t (often implemented as .close->:: when T:DataType)
}
/// Env-dependent DataType for T (contains E); imm rep is still T0.
DataType[T,E:*,T0]:ToInfo[E],ToImm[T,E,T0],WidenTo[T],OrderHash[T,E]{
  read .close(t: read T): read DataType[T,E,T0];             /// close on t in this env-dependent instance
  .close: read T;                                            /// closed fixpoint value

  /// Freeze the env by capturing element dictionaries in "by".
  /// Note: by may be a true dictionary supplier ({::}) or a projection ({::.key}).
  read .dataType[K](by: DataTypeBy[imm E,K,T0]): read DataType[T,T0] -> {
    .close t -> this.close(t).dataType(by);
    .close   -> this.close;
    .str     -> this.str(by);
    .info    -> this.info(by);
    .imm     -> this.imm(by);
    .hash h  -> this.hash[K](by,h);
    .cmp[R:**] t0,t1,m -> this.cmp[K,R](by,t0,t1,m);
  };
}

/// DataTypeBy is the "by key" dictionary, analogous to OrderHashBy.
/// It returns a closed DataType[K,K0] for each source value t:T.
/// Examples:
/// - If Key implements DataType[Key,Key0], then {::.key} : DataTypeBy[Foo,Key,Key0].
/// - {::} is the identity-by when T itself implements DataType[T,T0] (see DataTypeBy[T,T0] below).
DataTypeBy[T,K,K0]:ToInfoBy[T],ToImmBy[T,K0],OrderHashBy[T,K]{
  #(t: read T): read DataType[K,K0];
  .viewData[A](f:F[read A,read T]): DataTypeBy[A,K,K0] -> { # a -> this#(f#a) };

  /// Lexicographic composition on keys; you choose how to merge imm reps.
  /// Str merge is by ", " concat; Info merge uses Info.+ (you said it exists).
  .thenData[K1,K10,T0](next: DataTypeBy[T,K1,K10], mergeImm: F[K0,K10,T0]): DataTypeBy[T,T0] -> {
    .cmp t0,t1,m -> (this#t0) <=> (
      this#t1, {
        .lt->m.lt;
        .gt->m.gt;
        .eq->(next#t0) <=>(next#t1,m);
      });

    .hash t,h -> h#(this#t, next#t);

    .str  t -> this#t.str + `, ` + (next#t.str);
    .info t -> this#t.info + (next#t.info);

    .imm  t -> mergeImm#(this#t.imm, next#t.imm);
  };

  /// Convenience: keep left imm rep (often fine for "by key then tie-breaker").
  .thenDataLeft[K1,K10](next: DataTypeBy[T,K1,K10]): DataTypeBy[T,K0] ->
    this.thenData(next,{k0,k10->k0});
}

/// Specialized "datatype for T" (no external key type).
/// This mirrors OrderHashBy[T]: you provide per-value ops, and # closes into a DataType[T,T0].
DataTypeBy[T,T0]:DataTypeBy[T,T,T0]{
  .cmp[R:**](t0:read T,t1:read T,m:mut OrderMatch[R]): R;
  .hash(t:read T,h: mut Hasher): Nat;
  .str (t:read T): Str;
  .info(t:read T): Info;
  .imm (t:read T): T0;

  # t -> {
    .close -> t;
    .close t2 -> this#t2;
    .cmp t0,t1,m -> this.cmp(t0,t1,m);
    .hash h -> this.hash(t,h);
    .str  -> this.str(t);
    .info -> this.info(t);
    .imm  -> this.imm(t);
  };
}