package base;

NatArith:F[Tests,Tests]{::
  .test(5 + 7 .assertEq 12)
  .test(7 - 5 .assertEq 2)
  .test(3 * 4 .assertEq 12)

  .test(5 .assertLt 7)
  .test(7 .assertGt 5)

  // Unsigned ordering: 0xFFFFFFFF > 0
  .test((-1).aluNat .assertGt 0)
}

NatDivRem:F[Tests,Tests]{::
  .test(7 .div 3 .assertEq 2)
  .test(7 .rem 3 .assertEq 1)
  .test(6 .divExact 3 .assertEq ({::},Opts#(2)))
  .test(7 .divExact 3 .assertEq ({::},Opt[Nat]))
  .test(7 .divExact 0 .assertEq ({::},Opt[Nat]))

  .test(9 .sqrt .assertEq +3.0)
}

NatIndexOffset:F[Tests,Tests]{::
  .test(5 .indexOffset(-2) .assertEq 3)
  .test(5 .indexOffset(+2) .assertEq 7)
}

NatConv:F[Tests,Tests]{::
  .test(0.int .assertEq +0)
  .test(5.int .assertEq +5)

  .test(255.byte .assertEq (+255.byte))
  .test(300.byte .assertEq (+255.byte))

  .test(5.float .assertEq +5.0)
  .test(5.num .assertEq (+5.num))

  .test(5.intExact .assertEq ({::},Opts#(+5)))
  .test((-1).aluNat.intExact .assertEq ({::},Opt[Int]))

  .test(5.byteExact .assertEq ({::},Opts#(+5.byte)))
  .test(300.byteExact .assertEq ({::},Opt[Byte]))

  // clamp to maxInt
  .test((-1).aluNat.int .assertEq +2147483647)
}

NatAlu:F[Tests,Tests]{::
  .test((-1).aluNat.aluAddWrap 1 .assertEq 0)
  .test(0 .aluSubWrap 1 .aluInt .assertEq -1)
  .test(65536 .aluMulWrap 65536 .assertEq 0)

  // aluDiv / aluRem (unsigned)
  .test(7 .aluDiv 3 .assertEq 2)
  .test(7 .aluRem 3 .assertEq 1)
  .test((-1).aluNat.aluDiv 2 .aluInt .assertEq +2147483647)
  .test((-1).aluNat.aluRem 2 .assertEq 1)

  .test(1 .aluShiftLeft 32 .assertEq 1)
  .test((-1).aluNat .aluShiftRight 1 .aluInt .assertEq +2147483647)

  .test(5 .aluXor 3 .assertEq 6)
  .test(5 .aluAnd 3 .assertEq 1)
  .test(5 .aluOr 2 .assertEq 7)

  .test((-1).aluNat.aluInt .assertEq -1)
  .test((-1).aluNat.aluByte .assertEq (+255.byte))
}

NatRange:F[Tests,Tests]{::
  .test(3.assertInRange(1,5))
  .test(3.assertInRangeOpen(1,5))
  .test(3.assertInRangeLoOpen(1,3))
  .test(3.assertInRangeHiOpen(3,5))

  .test(0.clamp(1,5) .assertEq 1)
  .test(6.clamp(1,5) .assertEq 5)
  .test(3.clamp(1,5) .assertEq 3)
  .test(3.clamp(3,3) .assertEq 3)
}
NatLiteralForms:F[Tests,Tests]{::
  .test(1_000_000 .assertEq 1000000)
  .test(4_294_967_295 .assertEq 4294967295)

  // big literal interactions
  .test(4_294_967_295.byte .assertEq (+255.byte))
  .test(4_294_967_295.int .assertEq +2147483647)
}

NatBoundaryAndBoundedVsAlu:F[Tests,Tests]{::
  //.test(4294967295 + 1 .assertEq 4294967295)// correctly throws instead
  .test(4294967295.aluAddWrap 1 .assertEq 0)

  //.test(0 - 1 .assertEq 0) // correctly throws instead
  .test(0.aluSubWrap 1 .assertEq 4294967295)

  // 65536*65536 = 4294967296
  //.test(65536 * 65536 .assertEq 4294967295)// correctly throws instead
  .test(65536.aluMulWrap 65536 .assertEq 0)

  // bits-view sanity
  .test(4294967295.aluInt .assertEq -1)
}