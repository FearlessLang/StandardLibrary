package base;

DataType[T]: ToStr, ToInfo, WidenTo[T], ToImm[T], OrderHash[T], _AssertEq[T]{
  .close(x:T):DataType[T];
}
DataType[T,E:*]: ToStr[E], ToInfo[E], WidenTo[T], ToImm[T,E], OrderHash[T,E], _AssertEqGen[T,E]{
  .close(x:T):DataType[T,E];
  .close:T;
  .dataType(by: DataTypeBy[imm E]): DataType[T] -> {
    .close x -> this.close(x).dataType(by);
    .close   -> this.close;
    .str     -> this.str(by);
    .info    -> this.info(by);
    .imm     -> this.imm(by);
    .hash h  -> this.hash(by,h);
    .cmp a,b,lt,eq,gt -> this.cmp(by,a,b,lt,eq,gt);
  };
}
DataTypeBy[E]:ToStrBy[E],ToInfoBy[E],ToImmBy[E],OrderHashBy[E]{
  #(e:E): DataType[E];
}
ToImm[T]:{ read .imm: T }
ToImmBy[T]:{#(read T):read ToImm[T]}
ToImm[T,E:*]:{ read .imm(ToImmBy[imm E]): T }

ToStr:{ read .str: Str }
ToStrBy[T]:{#(read T):read ToStr}
ToStr[E:*]:{ read .str(ToStrBy[imm E]): Str }
ToInfo:{ read .info: Info }
FromInfo[T]:{ .fromInfo(i: Info): T }
ToInfoBy[T]:{#(read T):read ToInfo}
ToInfo[E:*]:{ read .info(by: ToInfoBy[imm E]): Info }

Order[T]: {
  .close:T;
  .cmp[R](a:T,b:T,lt:R,eq:R,gt:R): R;
  ==  (other: T): Bool -> this.cmp(this.close, other, False,True, False);
  <=  (other: T): Bool -> this.cmp(this.close, other, True, True, False);
  >=  (other: T): Bool -> this.cmp(this.close, other, False,True, True);
  <   (other: T): Bool -> this.cmp(this.close, other, True, False,False);
  >   (other: T): Bool -> this.cmp(this.close, other, False,False,True);
  !=  (other: T): Bool -> this.cmp(this.close, other, True, False,True);
  .inRange      (lo:T, hi:T): Bool-> _RangeTest#(this,lo,hi, this >= lo && { this <= hi }); /// true iff this in [lo,hi]; throws if lo>hi or lo/hi are NaN
  .inRangeOpen  (lo:T, hi:T): Bool-> _RangeTest#(this,lo,hi, this >  lo && { this <  hi }); /// true iff this in (lo,hi); throws if lo>hi or lo/hi are NaN
  .inRangeLoOpen(lo:T, hi:T): Bool-> _RangeTest#(this,lo,hi, this >  lo && { this <= hi }); /// true iff this in (lo,hi]; throws if lo>hi or lo/hi are NaN
  .inRangeHiOpen(lo:T, hi:T): Bool-> _RangeTest#(this,lo,hi, this >= lo && { this <  hi }); /// true iff this in [lo,hi); throws if lo>hi or lo/hi are NaN
  }
_RangeTest:{#[T](o:Order[T],lo:T,hi:T,res:Bool):Bool->
  Block#(Assert!(o.cmp(lo,hi, True, True, False)),res);
  }
OrderBy[T]:{
  #(T):Order[T];
  .then(other:OrderBy[T]):OrderByCmp[T] -> { .cmp[RR](a,b,lt,eq,gt)-> this#a.cmp[F[RR]](a,b,{lt},{ other#a.cmp(a,b,lt,eq,gt) },{gt})#};
  .and(other:OrderBy[T]):OrderByCmp[T] -> {a,b,lt,eq,gt-> this#a.cmp(a,b,lt,other#a.cmp(a,b,lt,eq,gt),gt)};
  .view[A](f:F[A,Order[T]]):OrderByCmp[A] -> {a,b,lt,eq,gt-> f#a.cmp(f#a.close,f#b.close,lt,eq,gt)};
}
OrderByCmp[T]:OrderBy[T]{
  .cmp[R](a:T,b:T,lt:R,eq:R,gt:R): R;
  # a0 -> { .close -> a0; .cmp a,b,lt,eq,gt -> this.cmp(a,b,lt,eq,gt) };
  }
Order[T,E:*]:{
  .close:T;
  .cmp[R](by: OrderBy[imm E], a:T,b:T, lt:R,eq:R,gt:R): R;
  .order(by: OrderBy[imm E]): Order[T] -> {
    .close -> this.close;
    .cmp a,b,lt,eq,gt -> this.cmp(by,a,b,lt,eq,gt);
    };
  }

Hasher: {
  //Note that his can be overridden in other hashes, so that #(a,b) just calls Block#(a.hash(this),b.hash(this)) while this accumulates on mut state
  mut #[A,B](a: OrderHash[A], b: OrderHash[B]): Nat -> a.hash(this) * 31 + (b.hash(this));
  //#[A,B,C](a: OrderHash[A], b: OrderHash[B], c: OrderHash[C]): Nat -> ...;
  //...//more overloads to compose more values
  mut .nat(v: Nat): Nat->v;
  mut .int(v: Int): Nat->Todo!;
  mut .num(v: Num): Nat->Todo!;
  mut .float(v: Float): Nat->Todo!;
  mut .byte(v: Byte): Nat->Todo!;
  mut .bool(v: Bool): Nat->v?{.then->0; .else->1};
  mut .info(i: Info): Nat->this.str(i.str); 
  mut .str(v: Str): Nat->Todo!;  
  mut .list[E](f: OrderHashBy[E],l: List[E]):Nat->Todo!;
  mut .opt[E](f: OrderHashBy[E], o: Opt[E]):Nat->Todo!;
  mut .map[K,E](f: OrderHashBy[E], m: Map[K,E]):Nat->Todo!;
  }
OrderHash[T]:Order[T]{ .hash(h: mut Hasher): Nat }
OrderHash[T,E:*]:Order[T,E]{
  .hash(by: OrderHashBy[imm E], h: mut Hasher): Nat;
  .orderH(by: OrderHashBy[imm E]): OrderHash[T] -> {'self
    .close -> this.close;
    .cmp a,b,lt,eq,gt -> this.cmp(by,a,b,lt,eq,gt);
    .hash h -> this.hash(by,h);
  };
}
OrderHashBy[T]:OrderBy[T]{
  #(x:T):OrderHash[T];
  .thenHash(other:OrderHashBy[T]):OrderHashByCmp[T] -> {
    .cmp[RR](a,b,lt,eq,gt)-> this#a.cmp[F[RR]](a,b,{lt},{ other#a.cmp(a,b,lt,eq,gt) },{gt})#;
    .hash(a,h)-> h#(this#a, other#a);
  };
  .andHash(other:OrderHashBy[T]):OrderHashByCmp[T] -> {
    .cmp[RR](a,b,lt,eq,gt)-> this#a.cmp[RR](a,b,lt, other#a.cmp(a,b,lt,eq,gt),gt);
    .hash(a,h)-> h#(this#a, other#a);
  };
  .viewHash[A](f:F[A,OrderHash[T]]):OrderHashByCmp[A] -> {
    .cmp(a,b,lt,eq,gt)-> f#a.cmp(f#a.close,f#b.close,lt,eq,gt);
    .hash(a,h)-> f#a.hash(h);
  };
}
OrderHashByCmp[T]:OrderHashBy[T]{
  .cmp[R](a:T,b:T,lt:R,eq:R,gt:R): R;
  .hash(a:T,h: mut Hasher):Nat;
  # a0 -> {
    .close -> a0;
    .cmp a,b,lt,eq,gt -> this.cmp(a,b,lt,eq,gt);
    .hash h -> this.hash(a0,h);
    };
}

/*Comparators is now dead!
We can now do
Ints.orderBy.view{::.age} && (Strs.orderBy.view{::.name})
and get an OrderBy[Person]
We can avoid view and overload orderBy:
Ints.orderBy{::.age} && (Strs.orderBy{::.name})
This is still sad, since we need Ints,Strs; we can not expect
user defined types to follow the pattern.
Instead the below should work (basically what Java does)
.max(Orders#{::.age} && { ::.name})
.max(Older && { ::.name})//works too
.max(Older && Taller)//works too
OlderAndTaller:OrderBy[Person]{a->{b->{Older && Taller #(a,b)}}
Orders:{#[T](t:OrderBy[T]):OrderBy[T]->t}
We can, for simplicity, also have
Orders:{
  #[T](t:OrderBy[T]):OrderBy[T]->t
  #[T](t1:OrderBy[T],t2:OrderBy[T]):OrderBy[T]->t1 && t2... but why?
  }
Or, we improve inference with guessing:
if e.m({..}.foo) and {..} does not declare a .foo method with type,
currently this is going to fail.
We can instead guess that {..} has the type needed by .m arg 1.
With this guessing, all the .andThen patterns would work
e.max({::.name} && {::.age})
No need of `Orders#` with this inference.
*/

//---tests
/*Persons:{#(name:Str, age:Nat):Person -> Person:{.name: Str -> name,  .age: Nat -> age }}
Older:OrderBy[Person]{ p1->{p2 -> p1.age <=> (p2.age) } }
//Yes inferred Older:OrderBy[Person]{ p1-> Order[Person]{p2 -> p1.age <=> (p2.age) } }

Persons:{#(name:Str, age:Num):Person -> Person:Order[Person]{
  .name: Str -> name,
  .age: Nat -> age,
  <=>(other)->this.age <=> (other.age) && {this.name <=> (other.name)},
  }}
*/