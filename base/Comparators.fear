/// Ordering + hashing via "closed fixpoints".
/// Intuition:
/// - An Order[T] is a comparator that is also a *closed* value: .close: T.
/// - Most concrete T implement Order[T] with .close->this.
/// - OrderBy[T,K] is a projection: given t:T, build a closed Order[K] for its key.
/// - OrderHash adds hashing and ToStr. This is all the Maps/Set may need.

ToStr:{ read .str: Str }            /// string representation

ToStrBy[T]:{                        /// per-value printer: given x:T, produce a ToStr for x
  #(read T):read ToStr
}

ToStr[E:*]:{                        /// ToStr that may mention values of E (printer strategy passed explicitly)
  read .str(ToStrBy[imm E]): Str
}

OrderMatch[R:**]:{                  /// compare result carrier: cmp selects exactly one of lt/eq/gt
  mut .lt:R;
  mut .eq:R;
  mut .gt:R;
}

Order[T]:{
  read .close: read T;              /// close fixpoint: the underlying value being ordered
  read .cmp[R:**](t0: read T, t1: read T, m: mut OrderMatch[R]): R; /// compare t0 vs t1 in this ordering

  // Derived relational ops: compare this.close against other (as a raw value).
  read ==  (other: read T): Bool -> this.cmp(this.close, other,{.lt ->False;.eq ->True; .gt -> False});
  read <=  (other: read T): Bool -> this.cmp(this.close, other,{.lt ->True;.eq ->True; .gt -> False});
  read >=  (other: read T): Bool -> this.cmp(this.close, other,{.lt ->False;.eq ->True; .gt -> True});
  read <   (other: read T): Bool -> this.cmp(this.close, other,{.lt ->True;.eq ->False; .gt -> False});
  read >   (other: read T): Bool -> this.cmp(this.close, other,{.lt ->False;.eq ->False; .gt -> True});
  read !=  (other: read T): Bool -> this.cmp(this.close, other,{.lt ->True;.eq ->False; .gt -> True});

  read .inRange(lo: read T, hi: read T):Bool-> Block#(Assert!(_LE#(this,lo,hi)), this >= lo  &&{ this <= hi });        /// true iff this in [lo,hi]; throws if lo>hi. For Float also throws if lo/hi are NaN
  read .inRangeOpen(lo: read T, hi: read T):Bool-> Block#(Assert!(_LE#(this,lo,hi)), this > lo  &&{ this < hi });      /// true iff this in (lo,hi); throws if lo>hi. For Float also throws if lo/hi are NaN
  read .inRangeLoOpen(lo: read T, hi: read T):Bool-> Block#(Assert!(_LE#(this,lo,hi)), this > lo  &&{ this <= hi });   /// true iff this in (lo,hi]; throws if lo>hi. For Float also throws if lo/hi are NaN
  read .inRangeHiOpen(lo: read T, hi: read T):Bool-> Block#(Assert!(_LE#(this,lo,hi)), this >= lo  &&{ this < hi });   /// true iff this in [lo,hi); throws if lo>hi. For Float also throws if lo/hi are NaN

  read <=>[R:**](other: read Order[T], m: mut OrderMatch[R]): R ->  /// compare two closed Orders
    this.cmp(this.close, other.close, m);
}
_LE:{ #[T](o: read Order[T], a: read T, b: read T): Bool -> o.cmp(a,b,{ .lt->True; .eq->True; .gt->False }) }


OrderBy[T,K]:{                       /// order values of T by a component/key K
  #(read T): read Order[K];          /// build a closed Order[K] for t's key (key is .close of the result)

  .then[K0](next: OrderBy[T,K0]): OrderBy[T] -> {  /// lexicographic: first this-key, then next-key
    .cmp(t0,t1,m)-> this#t0 <=>(
      this#t1, {
        .lt->m.lt;
        .gt->m.gt;
        .eq->next#t0<=>(next#t1,m);
      })
  };

  .view[A](f:F[read A,read T]):OrderBy[A] ->       /// contramap: order A by mapping into T
    {a0,a1,m-> this#(f#a0)<=>(this#(f#a1),m)};    
}

OrderBy[T]:OrderBy[T,T]{            /// produces an ordering via .cmp
  .cmp[R:**](t0:read T,t1:read T,m:mut OrderMatch[R]): R;
  # t -> { .close -> t; .cmp t0,t1,m -> this.cmp(t0,t1,m) }; /// close->t; compare uses this.cmp
}

Order[T,E:*]:{                      /// environment-dependent ordering of T (E supplies per-value orders)
  read .close:read T;

  read .cmp[K,R:**](by: OrderBy[imm E,K], t0: read T, t1: read T, m: mut OrderMatch[R]): R; /// compare using by

  read .order[K](by: OrderBy[imm E,K]): read Order[T] -> {  /// freeze by into a plain Order[T]
    .close -> this.close;
    .cmp t0,t1,m -> this.cmp(by,t0,t1,m);
  };
}
OrderHash[T]:Order[T],ToStr{            /// OrderHash adds hashing and ToStr. This is all the Maps/Set may need.
  read .hash(h: mut Hasher): Nat;
  read .close(t: read T): read OrderHash[T];
  
  read .assertEq(expected: read T):Void -> this.assertEq(expected,{``});
  read .assertEq(expected: read T, msg:F[Str]):Void -> Assert!(
    this == expected,
    { msg# | `Expected: `+(this.close(expected)) | `Actual: `+this });

  read .assertNe(expected: read T):Void -> this.assertNe(expected,{``});
  read .assertNe(expected: read T, msg:F[Str]):Void -> Assert!(
    this != expected,
    { msg# | `Unexpected: `+(this.close(expected)) | `Actual: `+this });

  read .assertLt(x: read T):Void -> this.assertLt(x,{``});
  read .assertLt(x: read T, msg:F[Str]):Void -> Assert!(
    this < x,
    { msg# | `Expected: `+this | ` < `+(this.close(x)) });
    
  read .assertLe(x: read T):Void -> this.assertLe(x,{``});
  read .assertLe(x: read T, msg:F[Str]):Void -> Assert!(
    this <= x,
    { msg# | `Expected: `+this | ` <= `+(this.close(x)) });

  read .assertGt(x: read T):Void -> this.assertGt(x,{``});
  read .assertGt(x: read T, msg:F[Str]):Void -> Assert!(
    this > x,
    { msg# | `Expected: `+this | ` > `+(this.close(x)) });

  read .assertGe(x: read T):Void -> this.assertGe(x,{``});
  read .assertGe(x: read T, msg:F[Str]):Void -> Assert!(
    this >= x,
    { msg# | `Expected: `+this | ` >= `+(this.close(x)) });
        
  read .assertInRange(lo: read T, hi: read T):Void -> this.assertInRange(lo,hi,{``});
  read .assertInRange(lo: read T, hi: read T, msg:F[Str]):Void -> Assert!(
    this.inRange(lo,hi),
    { msg# | `Expected in [lo,hi]`
      | `lo: `+(this.close(lo))
      | `hi: `+(this.close(hi))
      | `actual: `+this });
  
  read .assertInRangeOpen(lo: read T, hi: read T):Void -> this.assertInRangeOpen(lo,hi,{``});
  read .assertInRangeOpen(lo: read T, hi: read T, msg:F[Str]):Void -> Assert!(
    this.inRangeOpen(lo,hi),
    { msg# | `Expected in (lo,hi)`
      | `lo: `+(this.close(lo))
      | `hi: `+(this.close(hi))
      | `actual: `+this });
      
  read .assertInRangeLoOpen(lo: read T, hi: read T):Void -> this.assertInRangeLoOpen(lo,hi,{``});
  read .assertInRangeLoOpen(lo: read T, hi: read T, msg:F[Str]):Void -> Assert!(
    this.inRangeLoOpen(lo,hi),
    { msg# | `Expected in (lo,hi]`
      | `lo: `+(this.close(lo))
      | `hi: `+(this.close(hi))
      | `actual: `+this });
      
  read .assertInRangeHiOpen(lo: read T, hi: read T):Void -> this.assertInRangeHiOpen(lo,hi,{``});
  read .assertInRangeHiOpen(lo: read T, hi: read T, msg:F[Str]):Void -> Assert!(
    this.inRangeHiOpen(lo,hi),
    { msg# | `Expected in [lo,hi)`
      | `lo: `+(this.close(lo))
      | `hi: `+(this.close(hi))
      | `actual: `+this });
}

OrderHash[T,E:*]:Order[T,E],ToStr[E]{   /// env-dependent ordered+hashable+printable
  read .hash[K](by: OrderHashBy[imm E,K], h: mut Hasher): Nat; /// hash using by
  read .close(t: read T): read OrderHash[T,E];
  
  read .orderHash[K](by: OrderHashBy[imm E,K]): read OrderHash[T] -> { /// freeze by into plain OrderHash[T]
    .close -> this.close;
    .close t -> this.close(t).orderHash(by);
    .cmp t0,t1,m -> this.cmp(by,t0,t1,m);
    .hash h -> this.hash(by,h);
    .str  -> this.str by;
  };
  read .assertEq[K](by: OrderHashBy[imm E,K], expected: read T): Void -> this.orderHash(by).assertEq(expected);
  read .assertEq[K](by: OrderHashBy[imm E,K], expected: read T, msg: F[Str]): Void -> this.orderHash(by).assertEq(expected,msg);

  read .assertNe[K](by: OrderHashBy[imm E,K], expected: read T): Void -> this.orderHash(by).assertNe(expected);
  read .assertNe[K](by: OrderHashBy[imm E,K], expected: read T, msg: F[Str]): Void -> this.orderHash(by).assertNe(expected,msg);

  read .assertLt[K](by: OrderHashBy[imm E,K], x: read T): Void -> this.orderHash(by).assertLt(x);
  read .assertLt[K](by: OrderHashBy[imm E,K], x: read T, msg: F[Str]): Void -> this.orderHash(by).assertLt(x,msg);

  read .assertLe[K](by: OrderHashBy[imm E,K], x: read T): Void -> this.orderHash(by).assertLe(x);
  read .assertLe[K](by: OrderHashBy[imm E,K], x: read T, msg: F[Str]): Void -> this.orderHash(by).assertLe(x,msg);

  read .assertGt[K](by: OrderHashBy[imm E,K], x: read T): Void -> this.orderHash(by).assertGt(x);
  read .assertGt[K](by: OrderHashBy[imm E,K], x: read T, msg: F[Str]): Void -> this.orderHash(by).assertGt(x,msg);

  read .assertGe[K](by: OrderHashBy[imm E,K], x: read T): Void -> this.orderHash(by).assertGe(x);
  read .assertGe[K](by: OrderHashBy[imm E,K], x: read T, msg: F[Str]): Void -> this.orderHash(by).assertGe(x,msg);

  read .assertInRange[K](by: OrderHashBy[imm E,K], lo: read T, hi: read T): Void -> this.orderHash(by).assertInRange(lo,hi);
  read .assertInRange[K](by: OrderHashBy[imm E,K], lo: read T, hi: read T, msg: F[Str]): Void -> this.orderHash(by).assertInRange(lo,hi,msg);

  read .assertInRangeOpen[K](by: OrderHashBy[imm E,K], lo: read T, hi: read T): Void -> this.orderHash(by).assertInRangeOpen(lo,hi);
  read .assertInRangeOpen[K](by: OrderHashBy[imm E,K], lo: read T, hi: read T, msg: F[Str]): Void -> this.orderHash(by).assertInRangeOpen(lo,hi,msg);
      
  read .assertInRangeLoOpen[K](by: OrderHashBy[imm E,K], lo: read T, hi: read T): Void -> this.orderHash(by).assertInRangeLoOpen(lo,hi);
  read .assertInRangeLoOpen[K](by: OrderHashBy[imm E,K], lo: read T, hi: read T, msg: F[Str]): Void -> this.orderHash(by).assertInRangeLoOpen(lo,hi,msg);
     
  read .assertInRangeHiOpen[K](by: OrderHashBy[imm E,K], lo: read T, hi: read T): Void -> this.orderHash(by).assertInRangeHiOpen(lo,hi);
  read .assertInRangeHiOpen[K](by: OrderHashBy[imm E,K], lo: read T, hi: read T, msg: F[Str]): Void -> this.orderHash(by).assertInRangeHiOpen(lo,hi,msg);  
}

OrderHashBy[T,K]:OrderBy[T,K],ToStrBy[T]{  /// order+hash by key K, plus per-value printing of T
  #(t:read T): read OrderHash[K];          /// build closed OrderHash[K] for t's key

  .thenHash[K0](next: OrderHashBy[T,K0]): OrderHashBy[T] -> {  /// lexicographic order; hash mixes both keys
    .cmp t0,t1,m -> this#t0<=>(this#t1,{
      .lt ->m.lt;
      .eq ->next#t0<=>(next#t1,m);
      .gt ->m.gt});
    .hash t,h -> h#(this#t, next#t);
    .str t->this#t.str;
  };

  .viewHash[A](f:F[read A,read T]):OrderHashBy[A] -> {         /// contramap for both cmp and hash
    .cmp a0,a1,m -> this#(f#a0)<=>(this#(f#a1),m);
    .hash a,h -> this#(f#a).hash(h);
    .str t->this#(f#t).str;
  };
  .hideKey: OrderHashBy[T] -> {//Just convenience over .viewHash{::}
    .cmp t0,t1,m -> this#t0 <=> (this#t1,m);
    .hash t,h -> (this#t).hash(h);
    .str t ->this#t.str;
  };  
}

OrderHashBy[T]:OrderHashBy[T,T]{          /// direct order+hash for T
  .cmp[R:**](t0:read T,t1:read T,m:mut OrderMatch[R]): R;
  .hash(t: read T,h: mut Hasher):Nat;
  .str(t: read T): Str; 
  # t -> {                                /// close->t; compare/hash delegate to this.cmp/this.hash
    .close -> t; .close t0 -> this#t0; 
    .cmp t0,t1,m -> this.cmp(t0,t1,m);
    .hash h -> this.hash(t,h);
    .str -> this.str(t); 
  };
}