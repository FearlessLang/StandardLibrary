package base;

BoolMatch[R:**]:{
  mut .true: R;
  mut .false: R;
  }
Bool: Sealed,DataType[Bool]{
  .and(b: Bool): Bool;
  &&(b: mut MF[Bool]): Bool;
  &(b: Bool): Bool -> this.and(b);
  .or(b: Bool): Bool;
  |(b: Bool): Bool -> this.or(b);
  ||(b: mut MF[Bool]): Bool;
  .not: Bool;
  .if[R:**](f: mut ThenElse[R]): R;
  ?[R:**](f: mut ThenElse[R]): R -> this.if(f);
  .match[R](m: mut BoolMatch[R]): R -> this?{.then->m.true; .else->m.false};
  <=>other->Abort!;//TODO:
  .info->Abort!;//TODO:
  .asDataType->::;
  .hash(h)->h.bool(this);
  }
True: Bool{
  .and(b) -> b;
  &&(b) -> b#;
  .or(b) -> this;
  ||(b) -> this;
  .not -> False;
  .if(f) -> f.then;
  .str -> `True`;
  .imm -> True;
  }
False: Bool{
  .and(b) -> this;
  &&(b) -> this;
  .or(b) -> b;
  ||(b) -> b#;
  .not -> True;
  .if(f) -> f.else;
  .str -> `False`;
  .imm -> False;
  }
ThenElse[R:**]: { mut .then: R; mut .else: R; }