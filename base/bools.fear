BoolMatch[R:**]:{ mut .true: R; mut .false: R; }
ThenElse[R:**]: { mut .then: R; mut .else: R; }

Bool:Sealed,DataType[Bool,Bool]{
  .and(b: Bool): Bool;
  &&(b: mut MF[Bool]): Bool;
  &(b: Bool): Bool -> this.and(b);

  .or(b: Bool): Bool;
  |(b: Bool): Bool -> this.or(b);
  ||(b: mut MF[Bool]): Bool;

  .not: Bool;

  .if[R:**](f: mut ThenElse[R]): R;
  ?[R:**](f: mut ThenElse[R]): R -> this.if(f);

  .match[R:**](m: mut BoolMatch[R]): R -> this?{.then->m.true; .else->m.false};

  .close -> this; .close -> ::;

  .cmp a, b, m -> a.imm?{
    .then->b.imm?{ .then->m.eq; .else->m.gt };
    .else->b.imm?{ .then->m.lt; .else->m.eq };
    };

  .hash -> this.imm?{ .then->1; .else->0 };

  .str -> this.imm?{ .then->`True`; .else->`False` };

  .info -> Infos.msg(this.str);
  .assertTrue: Void -> this.assertEq True;
  .assertFalse: Void -> this.assertEq False;
}

True:Bool{
  .and(b) -> b;
  &&(b) -> b#;
  .or(b) -> this;
  ||(b) -> this;
  .not -> False;
  .if(f) -> f.then;
  .imm -> True;
}

False:Bool{
  .and(b) -> this;
  &&(b) -> this;
  .or(b) -> b;
  ||(b) -> b#;
  .not -> True;
  .if(f) -> f.else;
  .imm -> False;
}