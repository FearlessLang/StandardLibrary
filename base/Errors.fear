_Throw:{
  .deterministic[R:**](info:Info):R ->Magic!;
  .nonDeterministic[R:**](info:Info):R ->Magic!;
  .stackTrace:Info->Magic!
  }

/// Exception classes (observability):
/// - deterministic: The same operation called with observationally identical input
///   will either always throw or never throw.
///   Catchable anywhere via Try#.
/// - nonDeterministic: the throw may or may not happen in the same abstract situation
///   (OOM, stack overflow, asserts, etc).
///   Catching/observing requires mut CapTry obtained from mut System.
///
/// Asserts are nonDeterministic because another standard library may legally replace
/// them with no-ops.
Error: {
  ![R:**](info: Info): R -> _Throw.deterministic(info);
  .msg[R:**](msg: Str): R -> _Throw.deterministic(Infos.msg msg + (_Throw.stackTrace));
  .nonDeterministic[R:**](msg: Str): R -> _Throw.nonDeterministic(Infos.msg msg + (_Throw.stackTrace));
  }
Todo: {
  ![R:**]: R -> Error.msg `TODO: Implement this code.`;
  ![R:**](msg: Str): R -> Error.msg[R](`TODO: ` + msg);
  }
Unreachable: {
  ![R:**]: R -> Error.msg `This code was flagged as unreachable, but it has been reached.`;
  ![R:**](msg: Str): R -> Error.msg(`This code was flagged as unreachable as `+msg+`, but it has been reached.`);
  }
/// Strong exception safety is upheld:
/// The operation has either completed successfully or thrown an exception,
/// leaving the program state exactly as it was before the operation started.
Try: {
  #[R:*](try: read F[R]): mut Action[R] -> Magic!;
  #[T:iso,imm,mut,read,R:*](data: iso T, try: read F[iso T, R]): mut Action[R] -> Magic!;
  }