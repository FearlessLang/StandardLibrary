Opt[E:*]: _Opt[E]{
  .close->this; .close->::;
  .match m    -> m.empty;
  .imm by     -> this.match{.some x -> Opts#(by#x.imm); .empty->{} };
  .isEmpty    -> this.match{.some _ -> False; .empty -> True};
  .isSome     -> this.match{.some _ -> True; .empty -> False};  
  !           -> this.match{.some x -> x; .empty -> Error.msg `Opt was empty`};  

  .or default -> this.match{.some x -> x; .empty -> default};
  
  |   default -> this.or(default);
  ||  default -> this.match{.some x -> x; .empty -> default#};
  
  .flow       -> this.match{.empty -> Flows#; .some x -> Flows#(x)};

  .as[R] f    -> this.match{.some x->Opts#(f#x); .empty->{}};
  
  .ifSome  f  -> this.match{.some x -> f#x; .empty -> {}};
  .ifEmpty f  -> this.match{.some _ -> {}; .empty -> f#};

  .str  f  -> this.match{ .some x -> `Opt[`+(f#x)+`]`; .empty -> `Opt[]` };
  .info f  -> this.match{ .some x -> Infos.list(f#x); .empty -> {} };
  
  .cmp by, a, b, m -> a.match{
    .empty -> b.match{ .empty -> m.eq; .some _ -> m.lt; };
    .some ea -> b.match{
      .empty   -> m.gt;
      .some eb -> by#ea<=>(by#eb, m);
      }
    };
  .hash by -> this.match{
    .empty  -> 0;
    .some e -> 31.aluAddWrap(by#e.hash);
    };
  }
  
_Opt[E:*]:DataType[Opt[E],Opt[imm E],E,imm E],_AssertEmpty{
  mut  .match[R:**](mut OptMatch[E, R]): R;
  read .match[R:**](mut OptMatch[read/imm E, R]): R;
  imm  .match[R:**](mut OptMatch[imm E, R]): R;

  mut  .or(E): E;
  read .or(read/imm E): read/imm E;

  mut  |(E): E;
  read |(read/imm E): read/imm E;

  mut  ||(mut MF[E]): E;
  read ||(mut MF[read/imm E]): read/imm E;
  imm  ||(mut MF[imm E]): imm E;

  mut  !: E;
  read !: read/imm E;

  mut  .flow: mut Flow[E];
  read .flow: mut Flow[read/imm E];
  imm  .flow: mut Flow[imm E];

  mut  .ifSome(mut MF[E, Void]): Void;
  read .ifSome(mut MF[read/imm E, Void]): Void;
  imm  .ifSome(mut MF[imm E, Void]): Void;

  read .ifEmpty(mut MF[Void]): Void;

  read .isEmpty: Bool;
  read .isSome: Bool;
  read .as[R:imm](mut MF[read/imm E, R]): Opt[R];  
}

Opts:{
  #[E:*](x: E): mut Opt[E] -> { .match m -> m.some(x) };
}
OptMatch[E:*, R:**]:{
  mut .some(E): R;
  mut .empty: R;
}