Opt[E:*]: _Opt[E],_AssertEmpty{
  .close->this; .close->::;
  .match(m)   -> m.empty;
  .imm by     -> this.match[Opt[imm E]]{.some x -> Opts#(by#x.imm); .empty->{} };
  .isEmpty    -> this.match{.some _ -> False; .empty -> True};
  .isSome     -> this.match{.some _ -> True; .empty -> False};  
  !           -> this.match{.some x -> x; .empty -> Error.msg `Opt was empty`};  

  .or default -> this.match{.some x -> x; .empty -> default};
  
  |   default -> this.or(default);
  ||  default -> this.match{.some x -> x; .empty -> default#};
  
  .flow       -> this.match{.empty -> Flows#; .some x -> Flows#(x)};

  .as[R](f)   -> this.match[Opt[R]]{.some x->Opts#(f#x); .empty->{}};
  
  .ifSome(f)  -> this.match{.some x -> f#x; .empty -> {}};
  .ifEmpty(f) -> this.match{.some _ -> {}; .empty -> f#};

  .str(f) -> this.match{ .some x -> `Opt[`+(f#x)+`]`; .empty -> `Opt[]` };
  .info(f) -> this.match{ .some x -> Infos.list(f#x); .empty -> {} };
  
  .cmp by, a, b, m -> a.match{
    .empty -> b.match{ .empty -> m.eq; .some _ -> m.lt; };
    .some ea -> b.match{
      .empty   -> m.gt;
      .some eb -> by#ea<=>(by#eb, m);
      }
    };
  .hash by -> this.match{
    .empty  -> 0;
    .some e -> 31.aluAddWrap(by#e.hash);
    };
  }
  
_Opt[E:*]:DataType[Opt[E],Opt[imm E],E,imm E]{
  mut  .match[R:**](m: mut OptMatch[E, R]): R;
  read .match[R:**](m: mut OptMatch[read/imm E, R]): R;
  imm  .match[R:**](m: mut OptMatch[imm E, R]): R;

  mut  .or(default: E): E;
  read .or(default: read/imm E): read/imm E;

  mut  |(default: E): E;
  read |(default: read/imm E): read/imm E;

  mut  ||(default: mut MF[E]): E;
  read ||(default: mut MF[read/imm E]): read/imm E;
  imm  ||(default: mut MF[imm E]): imm E;

  mut  !: E;
  read !: read/imm E;

  mut  .flow: mut Flow[E];
  read .flow: mut Flow[read/imm E];
  imm  .flow: mut Flow[imm E];

  mut  .ifSome(f: mut MF[E, Void]): Void;
  read .ifSome(f: mut MF[read/imm E, Void]): Void;
  imm  .ifSome(f: mut MF[imm E, Void]): Void;

  read .ifEmpty(f: mut MF[Void]): Void;

  read .isEmpty: Bool;
  read .isSome: Bool;
  read .as[R:imm](f: mut MF[read/imm E, R]): Opt[R];  
}

Opts:{
  #[E:*](x: E): mut Opt[E] -> { .match(m) -> m.some(x) };
}
OptMatch[E:*, R:**]:{
  mut .some(x: E): R;
  mut .empty: R;
}