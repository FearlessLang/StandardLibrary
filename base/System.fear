package base;

System: ToIso[System], WidenTo[System]{
  //mut .io: mut IO;
  //mut .rng: mut RandomSeed;
  mut .try: mut CapTry;
  }
  
/// This try-catch will catch non-deterministic errors.
CapTry: ToIso[CapTry], WidenTo[CapTry]{
  /// This method upholds strong exception safety, so you can observe changes to
  ///  the program state from any exception-causing code.
  mut #[R:*](try: read F[R]): mut Action[R];
  /// This method is designed to take an iso object capability to do effects while handing
  /// the non deterministic exception.
  /// However any violations of strong exception safety can only be observed with an object
  /// capability because the iso reference is not linked to the outer world, so it is conceptually
  //  data that could have equivalently been recreated internally; and can not escape as mut
  mut #[T:**,R](data: iso T, try: read F[iso T,R]): mut Action[R];
  }
CapTrys: F[mut System, mut CapTry]{sys -> sys.try}
  