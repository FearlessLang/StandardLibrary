package base;

Tests:{
  .test(v: Void): Tests -> this;
  .done: Void -> {};
  .testSuite(f:F[Tests,Tests]):Tests -> f#this;
}

// -------------------- Float --------------------

FloatArith:F[Tests,Tests]{::
  .test((+1.0 + +2.0) .assertEq +3.0)
  .test((+5.0 - +2.0) .assertEq +3.0)
  .test((+3.0 * +4.0) .assertEq +12.0)
  .test((+7.0 / +2.0) .assertEq +3.5)
  .test((-3.0).abs .assertEq +3.0)
  .test((+9.0).sqrt .assertEq +3.0)
  .test((-1.0).sqrt.isNaN .assertEq True)
  .test((+2.0 ** +3.0) .assertEq +8.0)
  .test((+1.0).assertEqDelta(+1.0,+0.0))
}

FloatRound:F[Tests,Tests]{::
  .test(+0.5.round .assertEq +0)
  .test(+1.5.round .assertEq +2)
  .test(+2.5.round .assertEq +2)
  .test(-0.5.round .assertEq +0)
  .test(-1.5.round .assertEq -2)
  .test(-2.5.round .assertEq -2)

  // Near 1.5, eps = 1/64 = 0.015625 (exact)
  .test((+1.5 - (+1.0 / +64.0)).round .assertEq +1)
  .test((+1.5 + (+1.0 / +64.0)).round .assertEq +2)
  .test((-1.5 - (+1.0 / +64.0)).round .assertEq -2)

  .test((+1.5).floor .assertEq +1)
  .test((+1.5).ceil  .assertEq +2)
  .test((+1.5).trunc0 .assertEq +1)
  .test((-1.5).floor .assertEq -2)
  .test((-1.5).ceil  .assertEq -1)
  .test((-1.5).trunc0 .assertEq -1)

  // NaN/Inf policy for round
  .test((+0.0 / +0.0).round .assertEq +0)
  .test((+1.0 / +0.0).round .assertEq +2147483647)
  .test((-1.0 / +0.0).round .assertEq -2147483648)
}

FloatPred:F[Tests,Tests]{::
  .test((+0.0 / +0.0).isNaN .assertEq True)
  .test((+1.0 / +0.0).isInfinite .assertEq True)
  .test((+1.0 / +0.0).isPosInfinity .assertEq True)
  .test((+1.0 / +0.0).isNegInfinity .assertEq False)
  .test((-1.0 / +0.0).isNegInfinity .assertEq True)

  .test((-0.0).isNegZero .assertEq True)
  .test((-0.0).isPosZero .assertEq False)
  .test((+0.0).isPosZero .assertEq True)
  .test((+0.0).isNegZero .assertEq False)

  // Float == semantics: -0.0 == +0.0 ; NaN == NaN
  .test((-0.0) .assertEq +0.0)
  .test((+0.0 / +0.0) .assertEq (+0.0 / +0.0))

  // Ordering semantics: NaN is greater than everything
  .test((+0.0 / +0.0) .assertGt +1.0)
}

FloatIeee:F[Tests,Tests]{::
  .test((+0.0).ieeeEq(-0.0) .assertEq True)
  .test((+0.0).ieeeSameBits(-0.0) .assertEq False)
  .test((+0.0 / +0.0).ieeeEq(+0.0 / +0.0) .assertEq False)

  // IEEE remainder (ties-to-even)
  .test((+5.0).ieeeRemainder(+2.0) .assertEq +1.0)
  .test((+7.0).ieeeRemainder(+2.0) .assertEq -1.0)
}

FloatConv:F[Tests,Tests]{::
  .test((+1.5).int .assertEq +1)
  .test((-1.5).int .assertEq -1)
  .test((+1.5).nat .assertEq 1)
  .test((-1.5).nat .assertEq 0)
  .test((+300.0).byte .assertEq (+255.byte))
  .test((-1.0).byte .assertEq (+0.byte))

  .test((+0.0 / +0.0).int .assertEq +0)
  .test((+1.0 / +0.0).int .assertEq +2147483647)
  .test((-1.0 / +0.0).int .assertEq -2147483648)
  .test((+1.0 / +0.0).nat .assertEq (4294967295.aluInt.aluNat)) // avoid giant Nat literal: (maxInt).aluNat would not be maxNat

  // Exact conversions to Opt (assuming Opt is empty and Opts#(x) is some)
  .test((+3.0).intExact .assertEq ({::},Opts#(+3)))
  .test((+3.0).natExact .assertEq ({::},Opts#(3)))
  .test((+3.0).byteExact .assertEq ({::},Opts#(+3.byte)))
  .test((+1.5).intExact .assertEq ({::},Opt[Int]))
  .test((-1.0).natExact .assertEq ({::},Opt[Nat]))
  .test((+0.0 / +0.0).intExact .assertEq({::},Opt[Int]))
  .test((+1.0 / +0.0).byteExact .assertEq({::},Opt[Byte]))
}

FloatRange:F[Tests,Tests]{::
  .test((+3.0).assertInRange(+1.0,+5.0))
  .test((+3.0).assertInRangeOpen(+1.0,+5.0))
  .test((+3.0).assertInRangeLoOpen(+1.0,+3.0))
  .test((+3.0).assertInRangeHiOpen(+3.0,+5.0))
  .test((+0.0).clamp(+1.0,+5.0) .assertEq +1.0)
  .test((+6.0).clamp(+1.0,+5.0) .assertEq +5.0)
  .test((+3.0).clamp(+1.0,+5.0) .assertEq +3.0)
}

// -------------------- Num --------------------

NumArith:F[Tests,Tests]{::
  .test((+1.num + (+2.num)) .assertEq (+3.num))
  .test((+5.num - (+2.num)) .assertEq (+3.num))
  .test((+3.num * (+4.num)) .assertEq (+12.num))
  .test((+6.num / (+3.num)) .assertEq (+2.num))
  .test(-5.num.abs .assertEq (+5.num))
  .test(+9.num.sqrt .assertEq +3.0)
  .test(-1.num.sqrt.isNaN .assertEq True)
  .test(+1.num.assertEqDelta(+1.num,+0.num))
}

NumRound:F[Tests,Tests]{::
  .test(+1.num / (+2.num).round .assertEq (+0.num))
  .test(+3.num / (+2.num).round .assertEq (+2.num))
  .test(+5.num / (+2.num).round .assertEq (+2.num))
  .test(-1.num / (+2.num).round .assertEq (+0.num))
  .test(-3.num / (+2.num).round .assertEq (-2.num))
  .test(-5.num / (+2.num).round .assertEq (-2.num))
  .test(+1.num / (+3.num).round .assertEq (+0.num))
  .test(+2.num / (+3.num).round .assertEq (+1.num))
  .test(+1.num / (+2.num).round.isInteger .assertEq True)
}

NumFloorCeilTrunc:F[Tests,Tests]{::
  .test(+3.num / (+2.num).floor .assertEq (+1.num))
  .test(+3.num / (+2.num).ceil  .assertEq (+2.num))
  .test(+3.num / (+2.num).trunc0 .assertEq (+1.num))
  .test(-3.num / (+2.num).floor .assertEq (-2.num))
  .test(-3.num / (+2.num).ceil  .assertEq (-1.num))
  .test(-3.num / (+2.num).trunc0 .assertEq (-1.num))
}

NumIsInteger:F[Tests,Tests]{::
  .test(+2.num.isInteger .assertEq True)
  .test(+1.num / (+2.num).isInteger .assertEq False)
}

NumConv:F[Tests,Tests]{::
  .test((+5.num).int .assertEq +5)
  .test((+5.num).nat .assertEq 5)
  .test((+5.num).byte .assertEq (+5.byte))
  .test((+5.num).float .assertEq +5.0)

  .test(+1.num / (+2.num).int .assertEq +0)
  .test(-1.num / (+2.num).nat .assertEq 0)

  .test(+2.num.intExact .assertEq({::},Opts#(+2)))
  .test(+1.num / (+2.num).intExact .assertEq({::},Opt[Int]))
  .test(+2.num.natExact .assertEq({::},Opts#(2)))
  .test(-1.num.natExact .assertEq({::},Opt[Nat]))
  .test(+255.num.byteExact .assertEq({::},Opts#(+255.byte)))
  .test(+256.num.byteExact .assertEq({::},Opt[Byte]))
}

NumRange:F[Tests,Tests]{::
  .test(+3.num.assertInRange(+1.num,+5.num))
  .test(+3.num.assertInRangeOpen(+1.num,+5.num))
  .test(+3.num.assertInRangeLoOpen(+1.num,+3.num))
  .test(+3.num.assertInRangeHiOpen(+3.num,+5.num))
  .test(+0.num.clamp(+1.num,+5.num) .assertEq (+1.num))
  .test(+6.num.clamp(+1.num,+5.num) .assertEq (+5.num))
  .test(+3.num.clamp(+1.num,+5.num) .assertEq (+3.num))
}

// -------------------- Int --------------------

IntArith:F[Tests,Tests]{::
  .test((+1 + +2) .assertEq +3)
  .test((+5 - +2) .assertEq +3)
  .test((+3 * +4) .assertEq +12)
  .test((-7).abs .assertEq +7)
  .test((+9).sqrt .assertEq +3.0)
  .test((-1).sqrt.isNaN .assertEq True)

  .test((+1).assertLt(+2))
  .test((+2).assertLe(+2))
  .test((+2).assertGe(+2))
  .test((+3).assertGt(+2))
}

IntDivRem:F[Tests,Tests]{::
  .test((-7) .div 3 .assertEq -2)
  .test((-7) .rem 3 .assertEq -1)
  .test((+7) .div 3 .assertEq +2)
  .test((+7) .rem 3 .assertEq +1)
  .test((+6) .divExact 3 .assertEq ({::},Opts#(+2)))
  .test((+7) .divExact 3 .assertEq ({::},Opt[Int]))
  .test((+7) .divExact 0 .assertEq ({::},Opt[Int]))
}

IntWrapIndex:F[Tests,Tests]{::
  .test((-1) .wrapIndex 7 .assertEq 6)
  .test((+0) .wrapIndex 7 .assertEq 0)
  .test((+7) .wrapIndex 7 .assertEq 0)
  .test((+8) .wrapIndex 7 .assertEq 1)
}

IntConv:F[Tests,Tests]{::
  .test((-1).nat .assertEq 0)
  .test((+3).nat .assertEq 3)
  .test((-1).byte .assertEq (+0.byte))
  .test((+300).byte .assertEq (+255.byte))
  .test((+3).float .assertEq +3.0)
  .test((+3).num .assertEq (+3.num))

  .test((+3).natExact .assertEq ({::},Opts#3))
  .test((-1).natExact .assertEq ({::},Opt[Nat]))
  .test((+255).byteExact .assertEq ({::},Opts#(+255.byte)))
  .test((+256).byteExact .assertEq ({::},Opt[Byte]))
  .test((-1).byteExact .assertEq ({::},Opt[Byte]))
}

IntAlu:F[Tests,Tests]{::
  .test((+2147483647) .aluAddWrap(+1) .assertEq -2147483648)
  .test((-2147483648) .aluSubWrap(+1) .assertEq +2147483647)
  .test((+65536) .aluMulWrap(+65536) .assertEq +0)

  .test((-7) .aluDiv(+3) .assertEq -2)
  .test((-7) .aluDiv(-3) .assertEq +2)
  .test((-7) .aluRem(+3) .assertEq -1)
  .test((-7) .aluRem(-3) .assertEq -1)

  .test((+1) .aluShiftLeft 32 .assertEq +1)
  .test((-2) .aluShiftRight 1 .assertEq -1)

  .test((+1) .aluXor(+3) .assertEq +2)
  .test((+3) .aluAnd(+6) .assertEq +2)
  .test((+3) .aluOr(+4) .assertEq +7)

  .test((-1).aluNat.aluInt .assertEq -1)
  .test((+300).aluByte .assertEq (+44.byte))
}

IntRange:F[Tests,Tests]{::
  .test((+3).assertInRange(+1,+5))
  .test((+3).assertInRangeOpen(+1,+5))
  .test((+3).assertInRangeLoOpen(+1,+3))
  .test((+3).assertInRangeHiOpen(+3,+5))
  .test((+0).clamp(+1,+5) .assertEq +1)
  .test((+6).clamp(+1,+5) .assertEq +5)
  .test((+3).clamp(+1,+5) .assertEq +3)
}

// -------------------- Nat --------------------

NatArith:F[Tests,Tests]{::
  .test((5 + 7) .assertEq 12)
  .test((7 - 5) .assertEq 2)
  .test((3 * 4) .assertEq 12)
  .test(5 .assertLt 7)
  .test(7 .assertGt 5)

  // Unsigned ordering: 0xFFFFFFFF > 0
  .test((-1).aluNat .assertGt 0)
}

NatDivRem:F[Tests,Tests]{::
  .test(7 .div 3 .assertEq 2)
  .test(7 .rem 3 .assertEq 1)
  .test(6 .divExact 3 .assertEq({::}, Opts#(2)))
  .test(7 .divExact 3 .assertEq({::},  Opt[Nat]))
  .test(7 .divExact 0 .assertEq({::},  Opt[Nat]))
  .test(9 .sqrt .assertEq +3.0)
}

NatIndexOffset:F[Tests,Tests]{::
  .test(5 .indexOffset(-2) .assertEq 3)
  .test(5 .indexOffset(+2) .assertEq 7)
}

NatConv:F[Tests,Tests]{::
  .test(5.int .assertEq +5)
  .test(300.byte .assertEq (+255.byte))
  .test(5.float .assertEq +5.0)
  .test(5.num .assertEq (+5.num))

  .test(5.intExact .assertEq({::}, Opts#(+5)))
  .test((-1).aluNat.intExact .assertEq({::},  Opt[Int]))

  .test(5.byteExact .assertEq ({::}, Opts#(+5.byte)))
  .test(300.byteExact .assertEq({::},  Opt[Byte]))

  // clamp to maxInt
  .test((-1).aluNat.int .assertEq +2147483647)
}

NatAlu:F[Tests,Tests]{::
  .test((-1).aluNat .aluAddWrap 1 .assertEq 0)
  .test(0 .aluSubWrap 1 .aluInt .assertEq -1)
  .test(65536 .aluMulWrap 65536 .assertEq 0)

  .test(1 .aluShiftLeft 32 .assertEq 1)
  .test((-1).aluNat .aluShiftRight 1 .aluInt .assertEq +2147483647)

  .test(5 .aluXor 3 .assertEq 6)
  .test(5 .aluAnd 3 .assertEq 1)
  .test(5 .aluOr 2 .assertEq 7)

  .test((-1).aluNat.aluInt .assertEq -1)
  .test((-1).aluNat.aluByte .assertEq (+255.byte))
}

NatRange:F[Tests,Tests]{::
  .test(3.assertInRange(1,5))
  .test(3.assertInRangeOpen(1,5))
  .test(3.assertInRangeLoOpen(1,3))
  .test(3.assertInRangeHiOpen(3,5))
  .test(0.clamp(1,5) .assertEq 1)
  .test(6.clamp(1,5) .assertEq 5)
  .test(3.clamp(1,5) .assertEq 3)
}

// -------------------- Byte --------------------

ByteArith:F[Tests,Tests]{::
  .test((+1.byte + (+2.byte)) .assertEq (+3.byte))
  .test((+5.byte - (+2.byte)) .assertEq (+3.byte))
  .test((+3.byte * (+4.byte)) .assertEq (+12.byte))
  .test(+9.byte.sqrt .assertEq +3.0)

  // Unsigned ordering
  .test(+255.byte .assertGt (+0.byte))
}

ByteDivRem:F[Tests,Tests]{::
  .test(+7.byte.div 3 .assertEq (+2.byte))
  .test(+7.byte.rem 3 .assertEq (+1.byte))
  .test(+6.byte.divExact 3 .assertEq ({::},Opts#(+2.byte)))
  .test(+7.byte.divExact 3 .assertEq ({::},Opt[Byte]))
  .test(+7.byte.divExact 0 .assertEq ({::},Opt[Byte]))
}

ByteConv:F[Tests,Tests]{::
  .test(+255.byte.nat .assertEq 255)
  .test(+255.byte.int .assertEq +255)
  .test(+5.byte.float .assertEq +5.0)
  .test(+5.byte.num .assertEq (+5.num))
}

ByteAlu:F[Tests,Tests]{::
  .test(+250.byte.aluAddWrap(+10.byte) .assertEq (+4.byte))
  .test(+0.byte.aluSubWrap(+1.byte) .assertEq (+255.byte))
  .test(+16.byte.aluMulWrap(+16.byte) .assertEq (+0.byte))

  .test(+1.byte.aluShiftLeft 8 .assertEq (+1.byte))
  .test(+128.byte.aluShiftRight 1 .assertEq (+64.byte))

  .test(+5.byte.aluXor(+3.byte) .assertEq (+6.byte))
  .test(+5.byte.aluAnd(+3.byte) .assertEq (+1.byte))
  .test(+5.byte.aluOr(+2.byte) .assertEq (+7.byte))
}

ByteRange:F[Tests,Tests]{::
  .test(+3.byte.assertInRange(+1.byte,+5.byte))
  .test(+3.byte.assertInRangeOpen(+1.byte,+5.byte))
  .test(+3.byte.assertInRangeLoOpen(+1.byte,+3.byte))
  .test(+3.byte.assertInRangeHiOpen(+3.byte,+5.byte))
  .test(+0.byte.clamp(+1.byte,+5.byte) .assertEq (+1.byte))
  .test(+6.byte.clamp(+1.byte,+5.byte) .assertEq (+5.byte))
  .test(+3.byte.clamp(+1.byte,+5.byte) .assertEq (+3.byte))
}

// -------------------- Runner --------------------

TestNumbers:Main{s->
  Tests
    .testSuite FloatArith
    .testSuite FloatRound
    .testSuite FloatPred
    .testSuite FloatIeee
    .testSuite FloatConv
    .testSuite FloatRange

    .testSuite NumArith
    .testSuite NumRound
    .testSuite NumFloorCeilTrunc
    .testSuite NumIsInteger
    .testSuite NumConv
    .testSuite NumRange

    .testSuite IntArith
    .testSuite IntDivRem
    .testSuite IntWrapIndex
    .testSuite IntConv
    .testSuite IntAlu
    .testSuite IntRange

    .testSuite NatArith
    .testSuite NatDivRem
    .testSuite NatIndexOffset
    .testSuite NatConv
    .testSuite NatAlu
    .testSuite NatRange

    .testSuite ByteArith
    .testSuite ByteDivRem
    .testSuite ByteConv
    .testSuite ByteAlu
    .testSuite ByteRange
    .done
}